use std::collections::{BTreeMap, BTreeSet, HashMap};
use std::fmt::Display;
use std::fs::File;
use std::io::{BufWriter, Write};

use failure::Error;
use inflector::Inflector;

use super::code_writer::CodeWriter;
use super::expr::{CmpType, Expr};
use super::spec::{FieldSpec, PrimitiveType, Spec, SpecType, TypeSpec, VersionSpec};
use std::cmp::Ordering;

use std::path::MAIN_SEPARATOR;

#[derive(Debug, Clone, PartialEq, Eq)]
struct WrittenStruct {
    name: String,
    map_key: Option<Box<PreparedType>>,
}

#[derive(Debug, Clone)]
pub struct EntityType {
    pub name: String,
    pub doc: String,
    pub inner: PrimitiveType,
}

impl PartialOrd for EntityType {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.name.cmp(&other.name))
    }
}

impl Ord for EntityType {
    fn cmp(&self, other: &Self) -> Ordering {
        self.name.cmp(&other.name)
    }
}

impl PartialEq for EntityType {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name
    }
}

impl Eq for EntityType {}

fn primitive_default(prim: PrimitiveType) -> PreparedDefault {
    use PrimitiveType::*;
    match prim {
        Bool => PreparedDefault::Boolean(false),
        Int8 | Int16 | Uint16 | Int32 | Int64 => PreparedDefault::Numeric("0".into()),
        Float64 => PreparedDefault::Numeric("0.0".into()),
        String | Bytes | Records => PreparedDefault::Empty,
        Uuid => PreparedDefault::Uuid,
    }
}

fn parse_primitive_default(
    prim: PrimitiveType,
    default_str: String,
    type_: &PreparedType,
) -> PreparedDefault {
    use PrimitiveType::*;
    match prim {
        Int8 | Int16 | Int32 | Int64 | Float64 => PreparedDefault::Numeric(default_str),
        String => PreparedDefault::String(default_str),
        _ => panic!(
            "Unexpected default value {:?} for {}",
            default_str,
            type_.rust_name()
        ),
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
enum PreparedType {
    Primitive(PrimitiveType),
    Entity(EntityType),
    Struct(WrittenStruct),
    Array(Box<PreparedType>),
    Map(Box<PreparedType>, String),
}

impl PreparedType {
    fn rust_name(&self) -> String {
        match self {
            Self::Primitive(prim) => prim.rust_name().into(),
            Self::Entity(entity_type) => format!("super::{}", entity_type.name),
            Self::Struct(inner) => inner.name.clone(),
            Self::Array(inner) => format!("Vec<{}>", inner.rust_name()),
            Self::Map(key, value) => format!("indexmap::IndexMap<{}, {}>", key.rust_name(), value),
        }
    }
    fn name(&self, flexible: bool) -> String {
        match self {
            Self::Primitive(prim) => prim.name(flexible).into(),
            Self::Entity(entity_type) => entity_type.inner.name(flexible).into(),
            Self::Struct(_) => "types::Struct { version }".into(),
            Self::Array(inner) => {
                if flexible {
                    format!("types::CompactArray({})", inner.name(flexible))
                } else {
                    format!("types::Array({})", inner.name(flexible))
                }
            }
            Self::Map(_, _) => {
                if flexible {
                    "types::CompactArray(types::Struct { version })".into()
                } else {
                    "types::Array(types::Struct { version })".into()
                }
            }
        }
    }
    pub fn has_compact_form(&self) -> bool {
        match self {
            Self::Primitive(prim) => prim.has_compact_form(),
            Self::Entity(entity_type) => entity_type.inner.has_compact_form(),
            Self::Struct(_) => false,
            Self::Array(_) => true,
            Self::Map(_, _) => true,
        }
    }
    fn default(&self) -> PreparedDefault {
        match self {
            Self::Primitive(prim) => primitive_default(*prim),
            Self::Entity(entity_type) => primitive_default(entity_type.inner),
            Self::Struct(_) => PreparedDefault::EmptyStruct,
            Self::Array(_) | Self::Map(_, _) => PreparedDefault::Empty,
        }
    }
    fn is_entity(&self) -> bool {
        matches!(self, Self::Entity(_))
    }
}

enum PreparedDefault {
    Null,
    Empty,
    Boolean(bool),
    Numeric(String),
    String(String),
    Uuid,
    EmptyStruct,
}

impl PreparedDefault {
    fn gen_is_default(&self, expr: &Expr, optional: bool) -> Expr {
        if optional {
            if let Self::Null = self {
                expr.method("is_none", "")
            } else {
                expr.method("as_ref", "")
                    .method(
                        "map",
                        format!("|x| {}", self.gen_is_default(&Expr::new_atom("x"), false)),
                    )
                    .method("unwrap_or_default", "")
            }
        } else {
            match self {
                Self::Null => unreachable!(),
                Self::Empty => expr.method("is_empty", ""),
                Self::Boolean(true) => expr.deref(),
                Self::Boolean(false) => expr.deref().not(),
                Self::Numeric(v) => expr.deref().compare(CmpType::Eq, &Expr::new_atom(v)),
                Self::String(s) => expr.compare(CmpType::Eq, &Expr::new_str(s)),
                Self::Uuid => expr.compare(CmpType::Eq, &Expr::new_atom("&Uuid::nil()")),
                Self::EmptyStruct => {
                    expr.compare(CmpType::Eq, &Expr::new_atom("&Default::default()"))
                }
            }
        }
    }
    fn gen_default(&self, optional: bool, is_entity: bool) -> Expr {
        if optional {
            if let Self::Null = self {
                Expr::new_atom("None")
            } else {
                Expr::new_atom(&format!("Some({})", self.gen_default(false, is_entity)))
            }
        } else if is_entity {
            if let Self::Empty = self {
                self.gen_default(false, false)
            } else {
                self.gen_default(false, false).method("into", "")
            }
        } else {
            match self {
                Self::Null => unreachable!(),
                // TODO: unclear if empty struct default value can be used as zero val for comparison
                Self::Empty | Self::EmptyStruct => Expr::new_atom("Default::default()"),
                Self::Boolean(true) => Expr::new_atom("true"),
                Self::Boolean(false) => Expr::new_atom("false"),
                Self::Numeric(v) => Expr::new_unary(v),
                Self::String(s) => Expr::new_atom(&format!("StrBytes::from_str({:?})", s)),
                Self::Uuid => Expr::new_atom("Uuid::nil()"),
            }
        }
    }
}

struct PreparedField {
    name: String,
    optional: bool,
    type_: PreparedType,
    versions: VersionSpec,
    tag: Option<i32>,
    tagged_versions: VersionSpec,
    _nullable_versions: VersionSpec,
    default: PreparedDefault,
    ignorable: bool,
    _entity_type: Option<String>,
    map_key: bool,
    about: String,
    flexible_versions: VersionSpec,
}

impl PreparedField {
    fn var_name(&self) -> Expr {
        if self.map_key {
            Expr::new_atom("key")
        } else {
            Expr::new_atom("self").field(&self.name).by_ref()
        }
    }
}

fn prepare_field_type<W: Write>(
    w: &mut CodeWriter<W>,
    type_: &TypeSpec,
    field: &FieldSpec,
    common_structs_map_keys: &HashMap<String, PreparedType>, 
    entity_types: &mut BTreeSet<EntityType>,
    valid_versions: VersionSpec,
    flexible_msg_versions: VersionSpec,
) -> Result<PreparedType, Error> {
    Ok(match type_ {
        TypeSpec::Primitive(prim) => {
            if let Some(entity_type) = &field.entity_type {
                let entity_type = EntityType {
                    inner: *prim,
                    name: entity_type.to_pascal_case(),
                    doc: field.about.clone(),
                };
                entity_types.insert(entity_type.clone());
                PreparedType::Entity(entity_type)
            } else {
                PreparedType::Primitive(*prim)
            }
        }
        TypeSpec::Struct(name) => {
            if let Some(fields) = &field.fields {
                let written_struct = write_struct_def(
                    w,
                    name,
                    fields,
                    common_structs_map_keys,
                    entity_types,
                    valid_versions,
                    flexible_msg_versions,
                )?;
                PreparedType::Struct(written_struct)
            } else {
                PreparedType::Struct(WrittenStruct {
                    name: name.clone(),
                    map_key: None,
                })
            }
        }
        TypeSpec::Array(elem) => {
            let prepared_elem = prepare_field_type(
                w,
                elem,
                field,
                common_structs_map_keys,
                entity_types,
                valid_versions,
                flexible_msg_versions,
            )?;
            match prepared_elem {
                PreparedType::Struct(WrittenStruct {
                    name,
                    map_key: Some(map_key),
                }) => PreparedType::Map(map_key, name),
                PreparedType::Struct(WrittenStruct {
                    name,
                    map_key: None,
                }) if common_structs_map_keys.contains_key(&name) => {
                    // raw unwrap here because it's guaranteed by match guard
                    PreparedType::Map(Box::new(common_structs_map_keys.get(&name).unwrap().clone()), name.clone())
                },
                other => PreparedType::Array(Box::new(other)),
            }
        }
    })
}

fn prepare_common_struct_key_type(type_: &TypeSpec, field: &FieldSpec, entity_types: &mut BTreeSet<EntityType>) -> Result<PreparedType, Error> {
    Ok(match type_ {
        TypeSpec::Primitive(prim) => {
            if let Some(entity_type) = &field.entity_type {
                let entity_type = EntityType {
                    inner: *prim,
                    name: entity_type.to_pascal_case(),
                    doc: field.about.clone(),
                };
                entity_types.insert(entity_type.clone());
                PreparedType::Entity(entity_type)
            } else {
                PreparedType::Primitive(*prim)
            }
        }
        _ => panic!("Found key field in common structs that is not primitive or entity type (unimplemented use-case)"),
    })
}

fn write_version_cond<
    W: Write,
    FT: FnOnce(&mut CodeWriter<W>) -> Result<(), Error>,
    FF: FnOnce(&mut CodeWriter<W>) -> Result<(), Error>,
>(
    w: &mut CodeWriter<W>,
    valid_versions: VersionSpec,
    condition: VersionSpec,
    if_true: FT,
    if_false: FF,
    skip_true: bool,
    skip_false: bool,
) -> Result<(), Error> {
    let (min, max) = match valid_versions {
        VersionSpec::None => return Ok(()),
        VersionSpec::Exact(version) => (version, version),
        VersionSpec::Since(_) => panic!("Valid version range should be bounded"),
        VersionSpec::Range(a, b) => (a, b),
    };

    let condition = condition.intersect(valid_versions);
    let always_true = condition == valid_versions;
    if skip_true {
        if !always_true {
            match condition {
                VersionSpec::None => return if_false(w),
                VersionSpec::Exact(version) if version == max => {
                    write!(w, "if version < {} ", version)?
                }
                VersionSpec::Exact(version) => write!(w, "if version != {} ", version)?,
                VersionSpec::Since(version) => write!(w, "if version < {} ", version)?,
                VersionSpec::Range(a, b) if a == min => write!(w, "if version > {} ", b)?,
                VersionSpec::Range(a, b) if b == max => write!(w, "if version < {} ", a)?,
                VersionSpec::Range(a, b) => write!(w, "if version < {} || version > {} ", a, b)?,
            }
            w.block(if_false)?;
        }
    } else if always_true {
        if_true(w)?;
    } else {
        match condition {
            VersionSpec::None => return if_false(w),
            VersionSpec::Exact(version) if version == max => {
                write!(w, "if version >= {} ", version)?
            }
            VersionSpec::Exact(version) => write!(w, "if version == {} ", version)?,
            VersionSpec::Since(version) => write!(w, "if version >= {} ", version)?,
            VersionSpec::Range(a, b) if a == min => write!(w, "if version <= {} ", b)?,
            VersionSpec::Range(a, b) if b == max => write!(w, "if version >= {} ", a)?,
            VersionSpec::Range(a, b) => write!(w, "if version >= {} && version <= {} ", a, b)?,
        }
        w.block(if_true)?;
        if !skip_false {
            write!(w, " else ")?;
            w.block(if_false)?;
        }
    }
    Ok(())
}

fn write_encode_or_compute<W: Write, T: Display>(
    w: &mut CodeWriter<W>,
    type_: &str,
    var_name: T,
    compute_size: bool,
) -> Result<(), Error> {
    if compute_size {
        write!(w, "total_size += {}.compute_size({})?;", type_, var_name)?;
    } else {
        write!(w, "{}.encode(buf, {})?;", type_, var_name)?;
    }
    Ok(())
}

fn write_encode_field<W: Write>(
    w: &mut CodeWriter<W>,
    field: &PreparedField,
    valid_versions: VersionSpec,
    compute_size: bool,
) -> Result<(), Error> {
    if field
        .tagged_versions
        .contains(field.versions.intersect(valid_versions))
    {
        return Ok(());
    }

    write_version_cond(
        w,
        valid_versions,
        field.tagged_versions,
        |_| Ok(()),
        |w| {
            write_version_cond(
                w,
                valid_versions,
                field.versions,
                // field is used in this version, encode it
                |w| write_encode_field_inner(w, field, valid_versions, compute_size),
                // field is not present in this version, ensure that the default value is used
                |w| write_default_check(w, field),
                false,
                field.ignorable,
            )
        },
        true,
        false,
    )?;
    writeln!(w)?;
    Ok(())
}

fn write_encode_field_inner<W: Write>(
    w: &mut CodeWriter<W>,
    field: &PreparedField,
    valid_versions: VersionSpec,
    compute_size: bool,
) -> Result<(), Error> {
    let var_name = field.var_name();

    let valid_versions = valid_versions.intersect(field.versions);
    if !field.type_.has_compact_form() {
        write_encode_or_compute(w, &field.type_.name(false), &var_name, compute_size)
    } else {
        write_version_cond(
            w,
            valid_versions,
            field.flexible_versions,
            |w| write_encode_or_compute(w, &field.type_.name(true), &var_name, compute_size),
            |w| write_encode_or_compute(w, &field.type_.name(false), &var_name, compute_size),
            false,
            false,
        )
    }
}

fn write_default_check<W: Write>(
    w: &mut CodeWriter<W>,
    field: &PreparedField,
) -> Result<(), Error> {
    let var_name = field.var_name();

    let is_default = field
        .default
        .gen_is_default(&var_name, field.optional)
        .not();
    write!(w, "if {is_default} ")?;
    w.block(|w| {
        write!(w, "return Err(EncodeError)")?;
        Ok(())
    })
}

fn write_size_check<W: Write, T: Display>(
    w: &mut CodeWriter<W>,
    expr: T,
    t: &str,
    msg: &str,
) -> Result<(), Error> {
    writeln!(w, "if {} > std::{}::MAX as usize {{", expr, t)?;
    writeln!(w, "    error!({:?}, {});", msg, expr)?;
    writeln!(w, "    return Err(EncodeError);")?;
    writeln!(w, "}}")?;
    Ok(())
}

fn write_encode_tag_buffer<W: Write>(
    w: &mut CodeWriter<W>,
    prepared_fields: &[PreparedField],
    valid_versions: VersionSpec,
    flexible_msg_versions: VersionSpec,
    compute_size: bool,
) -> Result<(), Error> {
    write_version_cond(
        w,
        valid_versions,
        flexible_msg_versions,
        |w| {
            let valid_versions = valid_versions.intersect(flexible_msg_versions);

            let sorted_tagged_fields: BTreeMap<i32, &PreparedField> = prepared_fields
                .iter()
                .filter_map(|field| Some((field.tag?, field)))
                .collect();

            if sorted_tagged_fields.is_empty() {
                writeln!(
                    w,
                    "let num_tagged_fields = self.unknown_tagged_fields.len();"
                )?;
            } else {
                writeln!(
                    w,
                    "let mut num_tagged_fields = self.unknown_tagged_fields.len();"
                )?;
            }

            // Count number of tagged fields
            for field in sorted_tagged_fields.values() {
                let var_name = &field.var_name();
                write_version_cond(
                    w,
                    valid_versions,
                    field.tagged_versions,
                    |w| {
                        let valid_versions = valid_versions.intersect(field.tagged_versions);
                        write_version_cond(
                            w,
                            valid_versions,
                            field.versions,
                            |w| {
                                let is_default =
                                    field.default.gen_is_default(var_name, field.optional).not();
                                write!(w, "if {is_default} ")?;
                                w.block(|w| {
                                    write!(w, "num_tagged_fields += 1;")?;
                                    Ok(())
                                })
                            },
                            |_| Ok(()),
                            false,
                            true,
                        )?;
                        writeln!(w)?;
                        Ok(())
                    },
                    |_| Ok(()),
                    false,
                    true,
                )?;
            }

            write_size_check(
                w,
                "num_tagged_fields",
                "u32",
                "Too many tagged fields to encode ({} fields)",
            )?;
            write_encode_or_compute(
                w,
                "types::UnsignedVarInt",
                "num_tagged_fields as u32",
                compute_size,
            )?;
            writeln!(w)?;

            // Write out tagged fields
            let mut current_tag = -1;
            for (&k, field) in &sorted_tagged_fields {
                current_tag += 1;
                if k != current_tag {
                    if !compute_size {
                        writeln!(w, "write_unknown_tagged_fields(buf, {}..{}, &self.unknown_tagged_fields)?;", current_tag, k)?;
                    }
                    current_tag = k;
                }

                write_version_cond(
                    w,
                    valid_versions,
                    field.tagged_versions,
                    |w| {
                        let valid_versions = valid_versions.intersect(field.tagged_versions);
                        write_version_cond(
                            w,
                            valid_versions,
                            field.versions,
                            |w| {
                                write_encode_tag_buffer_inner(
                                    w,
                                    field,
                                    k,
                                    valid_versions,
                                    compute_size,
                                )
                            },
                            |w| write_default_check(w, field),
                            false,
                            field.ignorable,
                        )?;
                        writeln!(w)?;
                        Ok(())
                    },
                    |_| Ok(()),
                    false,
                    true,
                )?;
            }
            writeln!(w)?;

            if compute_size {
                write!(w, "total_size += compute_unknown_tagged_fields_size(&self.unknown_tagged_fields)?;")?;
            } else {
                write!(
                    w,
                    "write_unknown_tagged_fields(buf, {}.., &self.unknown_tagged_fields)?;",
                    current_tag + 1
                )?;
            }

            Ok(())
        },
        |_| Ok(()),
        false,
        true,
    )?;
    writeln!(w)?;
    Ok(())
}

fn write_encode_tag_buffer_inner<W: Write>(
    w: &mut CodeWriter<W>,
    field: &PreparedField,
    k: i32,
    valid_versions: VersionSpec,
    compute_size: bool,
) -> Result<(), Error> {
    let var_name = &field.var_name();
    let valid_versions = valid_versions.intersect(field.versions);
    let is_default = field.default.gen_is_default(var_name, field.optional).not();
    write!(w, "if {is_default} ")?;
    w.block(|w| {
        write!(w, "let computed_size = ")?;
        if !field.type_.has_compact_form() {
            write!(
                w,
                "{}.compute_size({})?",
                &field.type_.name(false),
                var_name
            )?;
        } else {
            write_version_cond(
                w,
                valid_versions,
                field.flexible_versions,
                |w| {
                    write!(w, "{}.compute_size({})?", &field.type_.name(true), var_name)?;
                    Ok(())
                },
                |w| {
                    write!(
                        w,
                        "{}.compute_size({})?",
                        &field.type_.name(false),
                        var_name
                    )?;
                    Ok(())
                },
                false,
                false,
            )?;
        }
        writeln!(w, ";")?;
        write_size_check(
            w,
            "computed_size",
            "u32",
            "Tagged field is too large to encode ({} bytes)",
        )?;
        write_encode_or_compute(w, "types::UnsignedVarInt", k, compute_size)?;
        writeln!(w)?;
        write_encode_or_compute(
            w,
            "types::UnsignedVarInt",
            "computed_size as u32",
            compute_size,
        )?;
        writeln!(w)?;
        if compute_size {
            writeln!(w, "total_size += computed_size;")?;
            Ok(())
        } else if !field.type_.has_compact_form() {
            write_encode_or_compute(w, &field.type_.name(false), var_name, compute_size)
        } else {
            write_version_cond(
                w,
                valid_versions,
                field.flexible_versions,
                |w| write_encode_or_compute(w, &field.type_.name(true), var_name, compute_size),
                |w| write_encode_or_compute(w, &field.type_.name(false), var_name, compute_size),
                false,
                false,
            )
        }
    })
}

fn write_decode_field<W: Write>(
    w: &mut CodeWriter<W>,
    field: &PreparedField,
    valid_versions: VersionSpec,
) -> Result<(), Error> {
    let var_name = if field.map_key {
        "key_field"
    } else {
        &field.name
    };

    if field.tagged_versions.is_none() {
        write!(w, "let {} = ", var_name)?;
    } else {
        write!(w, "let mut {} = ", var_name)?;
    }

    if field
        .tagged_versions
        .contains(field.versions.intersect(valid_versions))
    {
        writeln!(
            w,
            "{};",
            field
                .default
                .gen_default(field.optional, field.type_.is_entity())
        )?;
        return Ok(());
    }

    write_version_cond(
        w,
        valid_versions,
        field.tagged_versions,
        |w| {
            write!(
                w,
                "{}",
                field
                    .default
                    .gen_default(field.optional, field.type_.is_entity())
            )?;
            Ok(())
        },
        |w| {
            write_version_cond(
                w,
                valid_versions,
                field.versions,
                |w| {
                    let valid_versions = valid_versions.intersect(field.versions);
                    if !field.type_.has_compact_form() {
                        write!(w, "{}.decode(buf)?", field.type_.name(false))?;
                    } else {
                        write_version_cond(
                            w,
                            valid_versions,
                            field.flexible_versions,
                            |w| {
                                write!(w, "{}.decode(buf)?", field.type_.name(true))?;
                                Ok(())
                            },
                            |w| {
                                write!(w, "{}.decode(buf)?", field.type_.name(false))?;
                                Ok(())
                            },
                            false,
                            false,
                        )?;
                    }
                    Ok(())
                },
                |w| {
                    write!(
                        w,
                        "{}",
                        field
                            .default
                            .gen_default(field.optional, field.type_.is_entity())
                    )?;
                    Ok(())
                },
                false,
                false,
            )
        },
        false,
        false,
    )?;
    writeln!(w, ";")?;

    Ok(())
}

fn write_decode_tag_buffer<W: Write>(
    w: &mut CodeWriter<W>,
    prepared_fields: &[PreparedField],
    valid_versions: VersionSpec,
    flexible_msg_versions: VersionSpec,
) -> Result<(), Error> {
    write_version_cond(
        w,
        valid_versions,
        flexible_msg_versions,
        |w| {
            let valid_versions = valid_versions.intersect(flexible_msg_versions);

            let sorted_tagged_fields: BTreeMap<i32, &PreparedField> = prepared_fields
                .iter()
                .filter_map(|field| Some((field.tag?, field)))
                .collect();

            writeln!(
                w,
                "let num_tagged_fields = types::UnsignedVarInt.decode(buf)?;"
            )?;
            write!(w, "for _ in 0..num_tagged_fields ")?;
            w.block(|w| {
                writeln!(w, "let tag: u32 = types::UnsignedVarInt.decode(buf)?;")?;
                writeln!(w, "let size: u32 = types::UnsignedVarInt.decode(buf)?;")?;

                if sorted_tagged_fields.is_empty() {
                    writeln!(w, "let mut unknown_value = vec![0; size as usize];")?;
                    writeln!(w, "buf.try_copy_to_slice(&mut unknown_value)?;")?;
                    write!(
                        w,
                        "unknown_tagged_fields.insert(tag as i32, unknown_value);"
                    )?;
                    Ok(())
                } else {
                    write!(w, "match tag ")?;
                    w.block(|w| {
                        for (&k, field) in &sorted_tagged_fields {
                            let var_name = if field.map_key {
                                "key_field"
                            } else {
                                &field.name
                            };
                            write!(w, "{} => ", k)?;
                            w.block(|w| {
                                let tagged_field_versions =
                                    field.tagged_versions.intersect(field.versions);
                                write_version_cond(
                                    w,
                                    valid_versions,
                                    tagged_field_versions,
                                    |w| {
                                        let valid_versions =
                                            valid_versions.intersect(tagged_field_versions);
                                        if !field.type_.has_compact_form() {
                                            write!(
                                                w,
                                                "{} = {}.decode(buf)?;",
                                                var_name,
                                                field.type_.name(false)
                                            )?;
                                        } else {
                                            write_version_cond(
                                                w,
                                                valid_versions,
                                                field.flexible_versions,
                                                |w| {
                                                    write!(
                                                        w,
                                                        "{} = {}.decode(buf)?;",
                                                        var_name,
                                                        field.type_.name(true)
                                                    )?;
                                                    Ok(())
                                                },
                                                |w| {
                                                    write!(
                                                        w,
                                                        "{} = {}.decode(buf)?;",
                                                        var_name,
                                                        field.type_.name(false)
                                                    )?;
                                                    Ok(())
                                                },
                                                false,
                                                false,
                                            )?;
                                        }
                                        Ok(())
                                    },
                                    |w| {
                                        writeln!(
                                            w,
                                            "error!({:?}, tag, version);",
                                            "Tag {} is not valid for version {}"
                                        )?;
                                        write!(w, "return Err(DecodeError);")?;
                                        Ok(())
                                    },
                                    false,
                                    false,
                                )
                            })?;
                            writeln!(w, ",")?;
                        }
                        write!(w, "_ => ")?;
                        w.block(|w| {
                            writeln!(w, "let mut unknown_value = vec![0; size as usize];")?;
                            writeln!(w, "buf.try_copy_to_slice(&mut unknown_value)?;")?;
                            write!(
                                w,
                                "unknown_tagged_fields.insert(tag as i32, unknown_value);"
                            )?;
                            Ok(())
                        })
                    })
                }
            })
        },
        |_| Ok(()),
        false,
        true,
    )?;
    writeln!(w)?;
    Ok(())
}

fn write_struct_def<W: Write>(
    w: &mut CodeWriter<W>,
    name: &str,
    fields: &[FieldSpec],
    common_structs_map_keys: &HashMap<String, PreparedType>, 
    entity_types: &mut BTreeSet<EntityType>,
    valid_versions: VersionSpec,
    flexible_msg_versions: VersionSpec,
) -> Result<WrittenStruct, Error> {
    let mut prepared_fields = Vec::new();
    let mut map_key = None;

    let num_map_keys = fields.iter().filter(|field| field.map_key).count();

    for field in fields {
        let type_ = prepare_field_type(
            w,
            &field.type_,
            field,
            common_structs_map_keys,
            entity_types,
            valid_versions,
            flexible_msg_versions,
        )?;

        if field.map_key && num_map_keys == 1 {
            map_key = Some(Box::new(type_.clone()))
        }

        let mut name = field.name.to_snake_case();
        if name == "type" {
            name = "_type".to_string();
        }
        if name == "match" {
            name = "_match".to_string();
        }

        let optional = !field.nullable_versions.is_none();
        let versions = field.versions.intersect(valid_versions);
        let flexible_versions = field.flexible_versions.unwrap_or(flexible_msg_versions);
        let tagged_versions = field.tagged_versions;
        let nullable_versions = field.nullable_versions;

        assert!(flexible_msg_versions.contains(flexible_versions));
        assert!(flexible_versions.contains(tagged_versions));

        let default = if let Some(default) = &field.default {
            let default_str = match default {
                serde_json::Value::String(s) => s.clone(),
                other => other.to_string(),
            };

            match default_str.as_str() {
                "null" => {
                    assert!(nullable_versions.contains(field.versions));
                    PreparedDefault::Null
                }
                "true" | "false" => {
                    assert!(type_ == PreparedType::Primitive(PrimitiveType::Bool));
                    PreparedDefault::Boolean(default_str == "true")
                }
                _ => match &type_ {
                    PreparedType::Primitive(prim) => {
                        parse_primitive_default(*prim, default_str, &type_)
                    }
                    PreparedType::Entity(entity_type) => {
                        parse_primitive_default(entity_type.inner, default_str, &type_)
                    }
                    _ => panic!(
                        "Unexpected default value {:?} for {}",
                        default_str,
                        type_.rust_name()
                    ),
                },
            }
        } else {
            type_.default()
        };

        prepared_fields.push(PreparedField {
            name,
            optional,
            type_,
            versions,
            tag: field.tag,
            tagged_versions,
            _nullable_versions: field.nullable_versions,
            default,
            ignorable: field.ignorable.unwrap_or(false),
            _entity_type: field.entity_type.clone(),
            map_key: field.map_key && num_map_keys == 1,
            about: field.about.clone(),
            flexible_versions,
        });
    }

    writeln!(w, "/// Valid versions: {}", valid_versions)?;
    writeln!(w, "#[non_exhaustive]")?;
    writeln!(
        w,
        "#[derive(Debug, Clone, PartialEq, derive_builder::Builder)]"
    )?;
    writeln!(w, "#[builder(default)]")?;
    write!(w, "pub struct {} ", name)?;
    w.block(|w| {
        for prepared_field in &prepared_fields {
            if prepared_field.map_key {
                continue;
            }
            writeln!(w, "/// {}", prepared_field.about)?;
            writeln!(w, "/// ")?;
            writeln!(w, "/// Supported API versions: {}", prepared_field.versions)?;
            if prepared_field.optional {
                writeln!(
                    w,
                    "pub {}: Option<{}>,",
                    prepared_field.name,
                    prepared_field.type_.rust_name()
                )?;
            } else {
                writeln!(
                    w,
                    "pub {}: {},",
                    prepared_field.name,
                    prepared_field.type_.rust_name()
                )?;
            }
            writeln!(w)?;
        }

        if !flexible_msg_versions.is_none() {
            writeln!(w, "/// Other tagged fields")?;
            writeln!(w, "pub unknown_tagged_fields: BTreeMap<i32, Vec<u8>>,")?;
        }

        Ok(())
    })?;
    writeln!(w)?;
    writeln!(w)?;

    write!(w, "impl Builder for {} ", name)?;
    w.block(|w| {
        writeln!(w, "type Builder = {}Builder;", name)?;
        writeln!(w)?;
        write!(w, "fn builder() -> Self::Builder")?;
        w.block(|w| {
            writeln!(w, "{}Builder::default()", name)?;
            Ok(())
        })?;
        writeln!(w)?;
        Ok(())
    })?;
    writeln!(w)?;
    writeln!(w)?;

    if map_key.is_some() {
        write!(w, "impl MapEncodable for {} ", name)?;
    } else {
        write!(w, "impl Encodable for {} ", name)?;
    }
    w.block(|w| {
        if let Some(key) = &map_key {
            writeln!(w, "type Key = {};", key.rust_name())?;
            write!(w, "fn encode<B: ByteBufMut>(&self, key: &Self::Key, buf: &mut B, version: i16) -> Result<(), EncodeError> ")?;
        } else {
            write!(w, "fn encode<B: ByteBufMut>(&self, buf: &mut B, version: i16) -> Result<(), EncodeError> ")?;
        }
        w.block(|w| {
            for prepared_field in &prepared_fields {
                write_encode_field(w, prepared_field, valid_versions, false)?;
            }
            write_encode_tag_buffer(w, &prepared_fields, valid_versions, flexible_msg_versions, false)?;
            write!(w, "Ok(())")?;
            Ok(())
        })?;
        writeln!(w)?;
        if map_key.is_some() {
            write!(w, "fn compute_size(&self, key: &Self::Key, version: i16) -> Result<usize, EncodeError> ")?;
        } else {
            write!(w, "fn compute_size(&self, version: i16) -> Result<usize, EncodeError> ")?;
        }
        w.block(|w| {
            writeln!(w, "let mut total_size = 0;")?;
            for prepared_field in &prepared_fields {
                write_encode_field(w, prepared_field, valid_versions, true)?;
            }
            write_encode_tag_buffer(w, &prepared_fields, valid_versions, flexible_msg_versions, true)?;
            write!(w, "Ok(total_size)")?;
            Ok(())
        })?;
        Ok(())
    })?;
    writeln!(w)?;
    writeln!(w)?;

    if map_key.is_some() {
        write!(w, "impl MapDecodable for {} ", name)?;
    } else {
        write!(w, "impl Decodable for {} ", name)?;
    }
    w.block(|w| {
        if let Some(key) = &map_key {
            writeln!(w, "type Key = {};", key.rust_name())?;
            write!(w, "fn decode<B: ByteBuf>(buf: &mut B, version: i16) -> Result<(Self::Key, Self), DecodeError> ")?;
        } else {
            write!(w, "fn decode<B: ByteBuf>(buf: &mut B, version: i16) -> Result<Self, DecodeError> ")?;
        }
        w.block(|w| {
            for prepared_field in &prepared_fields {
                write_decode_field(w, prepared_field, valid_versions)?;
            }
            if !flexible_msg_versions.is_none() {
                writeln!(w, "let mut unknown_tagged_fields = BTreeMap::new();")?;
                write_decode_tag_buffer(w, &prepared_fields, valid_versions, flexible_msg_versions)?;
            }
            if map_key.is_some() {
                write!(w, "Ok((key_field, Self ")?;
            } else {
                write!(w, "Ok(Self ")?;
            }
            w.block(|w| {
                for prepared_field in &prepared_fields {
                    if !prepared_field.map_key {
                        writeln!(w, "{},", prepared_field.name)?;
                    }
                }

                if !flexible_msg_versions.is_none() {
                    writeln!(w, "unknown_tagged_fields,")?;
                }

                Ok(())
            })?;
            if map_key.is_some() {
                write!(w, "))")?;
            } else {
                write!(w, ")")?;
            }
            Ok(())
        })
    })?;
    writeln!(w)?;
    writeln!(w)?;

    write!(w, "impl Default for {} ", name)?;
    w.block(|w| {
        write!(w, "fn default() -> Self ")?;
        w.block(|w| {
            write!(w, "Self ")?;
            w.block(|w| {
                for prepared_field in &prepared_fields {
                    if !prepared_field.map_key {
                        writeln!(
                            w,
                            "{}: {},",
                            prepared_field.name,
                            prepared_field.default.gen_default(
                                prepared_field.optional,
                                prepared_field.type_.is_entity()
                            )
                        )?;
                    }
                }

                if !flexible_msg_versions.is_none() {
                    writeln!(w, "unknown_tagged_fields: BTreeMap::new(),")?;
                }

                Ok(())
            })
        })
    })?;
    writeln!(w)?;
    writeln!(w)?;

    write!(w, "impl Message for {} ", name)?;
    w.block(|w| {
        let range = valid_versions
            .range()
            .expect("Valid versions should be bounded.");
        writeln!(
            w,
            "const VERSIONS: VersionRange = VersionRange {{ min: {}, max: {} }};",
            range.start(),
            range.end()
        )?;
        Ok(())
    })?;
    writeln!(w)?;
    writeln!(w)?;

    Ok(WrittenStruct {
        name: name.into(),
        map_key,
    })
}

fn write_file_header<W: Write>(w: &mut CodeWriter<W>, name: &str) -> Result<(), Error> {
    writeln!(w, "//! {}", name)?;
    writeln!(w, "//!")?;
    writeln!(w, "//! See the schema for this message [here](https://github.com/apache/kafka/blob/trunk/clients/src/main/resources/common/message/{}.json).", name)?;
    writeln!(
        w,
        "// WARNING: the items of this module are generated and should not be edited directly"
    )?;
    writeln!(w, "#![allow(unused)]")?;
    writeln!(w)?;
    writeln!(w, "use std::borrow::Borrow;")?;
    writeln!(w, "use std::collections::BTreeMap;")?;
    writeln!(w)?;
    writeln!(w, "use bytes::Bytes;")?;
    writeln!(w, "use log::error;")?;
    writeln!(w, "use uuid::Uuid;")?;
    writeln!(w)?;
    writeln!(w, "use crate::protocol::{{")?;
    writeln!(w, "    Encodable, Decodable, MapEncodable, MapDecodable, Encoder, Decoder, EncodeError, DecodeError, Message, HeaderVersion, VersionRange,")?;
    writeln!(w, "    types, write_unknown_tagged_fields, compute_unknown_tagged_fields_size, StrBytes, buf::{{ByteBuf, ByteBufMut}}, Builder")?;
    writeln!(w, "}};")?;
    writeln!(w)?;
    writeln!(w)?;
    Ok(())
}

pub fn generate(
    output_path: &str,
    spec: Spec,
    entity_types: &mut BTreeSet<EntityType>,
) -> Result<(String, String), Error> {
    let struct_name = spec.name.clone();
    let module_name = struct_name.to_snake_case();

    let file_name = format!("{}{}{}.rs", output_path, MAIN_SEPARATOR, module_name);
    let mut file = CodeWriter::new(BufWriter::new(File::create(file_name)?));

    let valid_versions = spec.valid_versions;
    let flexible_msg_versions = spec.flexible_versions.unwrap_or_default();

    write_file_header(&mut file, &struct_name)?;

    let mut common_structs_map_keys: HashMap<String, PreparedType> = HashMap::new();

    for common_struct in &spec.common_structs {
        let num_map_keys = common_struct.fields.iter().filter(|&field| field.map_key).count();

        for field in &common_struct.fields {
            if field.map_key && num_map_keys == 1 {
                common_structs_map_keys.insert(common_struct.name.clone(), prepare_common_struct_key_type(&field.type_, field, entity_types)?);
                break;
            };
        }
    }

    for common_struct in &spec.common_structs {
        write_struct_def(
            &mut file,
            &common_struct.name,
            &common_struct.fields,
            &common_structs_map_keys,
            entity_types,
            valid_versions,
            flexible_msg_versions,
        )?;
    }
    write_struct_def(
        &mut file,
        &struct_name,
        &spec.fields,
        &common_structs_map_keys,
        entity_types,
        valid_versions,
        flexible_msg_versions,
    )?;

    if let Some(api_key) = spec.api_key {
        write!(&mut file, "impl HeaderVersion for {} ", struct_name)?;
        file.block(|w| {
            write!(w, "fn header_version(version: i16) -> i16 ")?;
            w.block(|w| {
                match (spec.type_, api_key) {
                    // ApiVersionsResponse always includes a v0 header.
                    // See KIP-511 for details.
                    (SpecType::Response, 18) => {
                        write!(w, "0")?;
                    }
                    (SpecType::Request, _) => {
                        write_version_cond(
                            w,
                            valid_versions,
                            flexible_msg_versions,
                            |w| {
                                write!(w, "2")?;
                                Ok(())
                            },
                            |w| {
                                // Version 0 of ControlledShutdownRequest has a non-standard request header
                                // which does not include clientId.  Version 1 of ControlledShutdownRequest
                                // and later use the standard request header.
                                if api_key == 7 {
                                    write!(w, "if version == 0 {{ 0 }} else {{ 1 }}")?;
                                } else {
                                    write!(w, "1")?;
                                }
                                Ok(())
                            },
                            false,
                            false,
                        )?;
                    }
                    (SpecType::Response, _) => {
                        write_version_cond(
                            w,
                            valid_versions,
                            flexible_msg_versions,
                            |w| {
                                write!(w, "1")?;
                                Ok(())
                            },
                            |w| {
                                write!(w, "0")?;
                                Ok(())
                            },
                            false,
                            false,
                        )?;
                    }
                    _ => unreachable!(),
                }
                Ok(())
            })
        })?;
        writeln!(&mut file)?;
        writeln!(&mut file)?;
    }

    Ok((module_name, struct_name))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::generate_messages::spec::VersionSpec;

    #[test]
    fn write_version_cond_unknown_tagged() -> Result<(), Box<dyn std::error::Error>> {
        let mut cw = CodeWriter::new(Vec::new());

        // ex. request header
        let v1 = VersionSpec::Range(0, 2);
        let v2 = VersionSpec::Since(2);

        write_version_cond(
            &mut cw,
            v1,
            v2,
            |w| {
                write!(w, "true")?;
                Ok(())
            },
            |_| Ok(()),
            false,
            true,
        )?;

        assert_eq!(
            String::from_utf8(cw.into_inner()).unwrap(),
            "if version >= 2 {\n    true\n}".to_string()
        );
        Ok(())
    }
}
